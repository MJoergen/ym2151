# YM2151 : Step-by-step implementation
# Episode 6 : "Configuration"

Welcome to the sixth episode of "YM2151 : Step-by-step implementation", where
we implement the configuration interface. The purpose is to allow an external
module to configure (in real time) the notes to be played. This will be the
first time we can actually play some music directly from the FPGA!

## Configurator
The changes are first and foremost in the configurator module, which is
basically rewritten from scratch.

The configuration state of the chip is stored in a series
of arrays: range\_20\_r, range\_40\_r, ... , range\_e0\_r.
The reason for this is to make it easier to generate the output signals.

One additional complexity is that the configuration interface to the YM2151 is
running at the fast clock, whereas the current slot configuration is running at
the slower (halved) clock. Therefore, the configurator module must have both
clocks in. Since the slow and fast clocks are synchronous to each other, and
are running at a sufficiently low speed, it is not necessary to make special
Clock Domain Crossing considerations.

With the above changes, the design now correctly reacts to register writes!
Mind you, only a few register addresses are currently supported, but that will
change as we add more features to the design.

## Testing in simulation
In this and the following episodes, I will use a different testbench strategy,
where the testbench automatically verifies the output.

The main test code is in the file ym2151\_tb.vhd in the process p\_test.
Here the stimuli are generated and the output is verified.

The stimuli generated consists of first a single note "A1" (55 Hz) combined
with various values of the key fraction, and subsequently a single note "C#3"
(138.591 Hz) again with various key fractions. The stimuli are generated by
calling the procedure ym2151\_write\_config, more on that later.

The individual tests are handled in the procedure run\_test\_frequency, which
also verifies the output.  This procedure first pushes the configuration to the
YM2151, then calculates the expected frequency in Hz, and finally the expected
period in number of samples.

Then run\_test\_frequency monitors the output for five periods, and counts the
number of samples between each rising edge of the output. Here rising edge is
defined as transition from small negative value to small positive value.

A small discrepancy of around 0.1% is allowed to account for sampling error
etc.

## Bus Functional Model
To help write the testbench I've added the file ym2151\_bfm\_pkg.vhd.
This file contains:
* A record (ym2151\_if\_t) corresponding to the input signals to the YM2151.
* A record (config\_t) corresponding to the entire configuration of the YM2151.
* The procedure ym2151\_write\_config that writes the configuration to the YM2151.

Using the above, it is possible to write tests in a procedural style.

## Testing in hardware
A lot of additional work is required in order to test the new configuration
interface in hardware.  The point being that the YM2151 now relies on receiving
the configuration from an external entity, rather than the specific tones being
hardcoded in the design.

So the example design in the nexys4ddr directory will be expanded to include a
simple controller moduler, ctrl. The purpose of this module is to read
configuration information from a ROM and to generate the configuration signals
for the YM2151 module. The contents of the ROM are in turn derived from a text
file "music.txt".

## Format of the file "music.txt"
So this text file contains the register writes to the YM2151.  Each line
consists of a 2-byte hexadecimal number. The first byte denotes the register
address and the second byte the register value.  For instance, the line "2087"
means write the hexadecimal value 0x87 to the register at hexadecimal address
0x20.

The file music.txt used in this episode consists of a number of register
writes, many of which are not yet supported by the current design. However, on
the real YM2151 (or any emulator) these register writes are necessary in order
to get the YM2151 to produce a sound. For instance, some of these register
writes configure the envelope generator, a topic for the next episode.

With the current contents of the file music.txt the current design will produce
the same output as the real chip: Three musical notes, with the following
frequencies and volumes:
* A4 (with frequency 440 Hz) @ -12 dB.
* E5 (with frequency 659 Hz) @ -24 dB.
* C6 (with frequency 1047 Hz) @ -18 dB.

## The controller module "ctrl"
This module instantiates a 16-bit wide ROM and populates (at synthesis time)
the ROM with the contents from the text file music.txt. After reset, the
controller module reads the ROM and generates the corresponding register writes
to the YM2151 module.

There is a special case, when the register address is equal to zero (0x00).
The controller module will, rather than issuing a register write, instead wait
a number of clock cycles determined by the corresponding register value, in
units of approximately 2 ms. So the line 00FF will wait for the maximum amount
of time, which is approximately half a second.

Finally, the value 0000 will wait indefinetely, i.e. stops all further register
writes.

The controller module "ctrl" is instantiated in the top level file
nexys4ddr.vhd.

When running in hardware the design correctly generates the three notes above.
So now it is possible to use a text file to control the register writes to the
YM2151.

